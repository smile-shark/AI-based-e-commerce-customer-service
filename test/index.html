<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>传统客服 vs AI客服流程对比 (高清修复版)</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
    <style>
        #editor {
            font-family: 'Fira Code', monospace;
            resize: none;
        }
        .mermaid-container {
            background-color: #f8fafc;
            border-radius: 8px;
            cursor: grab;
        }
        .mermaid-container:active {
            cursor: grabbing;
        }
        #graphContainer svg {
            max-width: none !important;
            width: 100%;
            height: 100%;
        }
        .dropdown:hover .dropdown-menu {
            display: block;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">
<!-- 头部 -->
<header class="bg-white border-b px-6 py-4 flex justify-between items-center shadow-sm z-20">
    <div class="flex items-center gap-4">
        <h1 class="text-xl font-bold text-gray-800">客服模式深度对比预览</h1>
        <span class="text-xs bg-purple-100 text-purple-600 px-2 py-1 rounded">左：传统模式 | 右：AI模式</span>
    </div>
    <div class="space-x-2 flex items-center">
        <button id="resetZoomBtn" class="bg-white border border-gray-300 hover:bg-gray-50 text-gray-700 px-3 py-2 rounded-lg text-sm transition">
            适应屏幕
        </button>
        <button id="renderBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition text-sm font-medium">
            重新渲染
        </button>

        <div class="relative inline-block dropdown">
            <button class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition text-sm font-medium inline-flex items-center">
                <span>导出高清图片</span>
                <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div class="dropdown-menu absolute right-0 hidden pt-2 w-32 z-30">
                <div class="bg-white border shadow-xl rounded-lg overflow-hidden">
                    <button onclick="exportImage('png')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">导出 PNG</button>
                    <button onclick="exportImage('jpg')" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">导出 JPG</button>
                </div>
            </div>
        </div>

        <button id="downloadBtn" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition text-sm">
            复制源码
        </button>
    </div>
</header>

<!-- 主体 -->
<main class="flex-1 flex overflow-hidden p-4 gap-4">
    <!-- 编辑区 -->
    <div class="w-1/4 flex flex-col bg-white rounded-xl shadow-sm border overflow-hidden">
        <div class="bg-gray-50 px-4 py-2 border-b text-sm font-medium text-gray-500 flex justify-between">
            <span>Mermaid 源码</span>
        </div>
        <textarea id="editor" class="flex-1 p-4 outline-none text-sm leading-relaxed text-gray-700">graph LR
    %% 使用 LR (Left to Right) 确保两个大的 Subgraph 横向排列，内部逻辑 TB (Top Bottom)

    %% 样式定义
    classDef bad_node fill:#ffebee,stroke:#c62828,stroke-width:2px;
    classDef good_node fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px;
    classDef neutral_node fill:#f5f5f5,stroke:#9e9e9e,stroke-width:1px;
    classDef highlight_node fill:#fff9c4,stroke:#fbc02d,stroke-width:2px;

    subgraph TRADITIONAL [1. 传统人工客服流程 - 痛点明显]
        direction TB
        T1[用户咨询] --> T2{排队等待}
        T2 -->|峰值时段| T3[漫长排队/用户流失]:::bad_node
        T2 -->|介入| T4[人工接待]
        T4 --> T5{简单重复问题?}
        T5 -->|是| T6[人工重复解答]:::bad_node
        T5 -->|否| T7[复杂问题沟通]
        T7 --> T8[商户反复查阅文档]:::bad_node
        T8 --> T9[回复延迟]:::bad_node
        T9 --> T10[人工手动记录/整理]:::bad_node

        T6 --> T11[人力成本高/效率低]:::bad_node
        T10 --> T11
    end

    %% 占位符确保间距
    TRADITIONAL --- SPACE((对比)) --- AI_POWERED

    subgraph AI_POWERED [2. AI 智能客服流程 - 降本增效]
        direction TB
        A1[用户咨询] --> A2{AI 预检}
        A2 -->|秒级响应| A3{分流策略}:::good_node

        A3 -->|简单/常见| A4[AI 基于RAG精准秒回]:::good_node
        A3 -->|复杂/转人工| A5[无缝介入人工]

        A4 --> A6[24/7 全天候在线]:::good_node
        A4 --> A7[自动更新记忆/知识库]:::good_node

        A5 --> A8[AI 辅助查阅/建议回复]:::highlight_node
        A8 --> A9[人工仅需审核点击]:::good_node

        A7 --> A10[极低边际成本/高并发]:::good_node
        A9 --> A10
    end

    %% 标注
    class T3,T6,T8,T9,T10,T11 bad_node;
    class A3,A4,A6,A7,A9,A10 good_node;
    class A8 highlight_node;
    style SPACE fill:none,stroke:none,color:#999;</textarea>
    </div>

    <!-- 预览区 -->
    <div class="flex-1 flex flex-col bg-white rounded-xl shadow-sm border overflow-hidden relative">
        <div class="bg-gray-50 px-4 py-2 border-b text-sm font-medium text-gray-500 flex justify-between items-center">
            <span>可视化对比预览 (左：传统 / 右：AI)</span>
            <span class="text-xs text-gray-400">红色为痛点，绿色为优势</span>
        </div>
        <div id="preview" class="flex-1 mermaid-container">
            <div id="graphContainer" class="w-full h-full flex items-center justify-center">
            </div>
        </div>
        <div class="absolute bottom-4 right-4 bg-white/80 backdrop-blur shadow border rounded px-3 py-1 text-xs text-gray-500 pointer-events-none">
            滚轮缩放 · 鼠标拖拽
        </div>
    </div>
</main>

<script>
    let panZoomInstance = null;

    mermaid.initialize({
        startOnLoad: false,
        theme: 'default',
        securityLevel: 'loose',
        flowchart: { useMaxWidth: false, htmlLabels: true }
    });

    const editor = document.getElementById('editor');
    const container = document.getElementById('graphContainer');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const resetZoomBtn = document.getElementById('resetZoomBtn');

    async function renderGraph() {
        const code = editor.value;
        if (panZoomInstance) {
            panZoomInstance.destroy();
            panZoomInstance = null;
        }
        container.innerHTML = `<div class="mermaid">${code}</div>`;
        try {
            await mermaid.run({ nodes: [container.querySelector('.mermaid')] });
            const svgElement = container.querySelector('svg');
            if (svgElement) {
                svgElement.style.height = "100%";
                svgElement.style.width = "100%";
                panZoomInstance = svgPanZoom(svgElement, {
                    zoomEnabled: true,
                    controlIconsEnabled: true,
                    fit: true,
                    center: true,
                    minZoom: 0.1,
                    maxZoom: 10
                });
            }
        } catch (err) { console.error("渲染错误:", err); }
    }

    async function exportImage(format) {
        const svgElement = container.querySelector('svg');
        if (!svgElement) return;

        // 1. 获取准确的视图框和尺寸
        // 使用 getBBox 获取 SVG 内容的实际边界
        const bbox = svgElement.getBBox();
        const padding = 60; // 边缘留白
        const width = bbox.width + padding * 2;
        const height = bbox.height + padding * 2;

        // 2. 深度克隆并处理 SVG 源码
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgElement);

        // 确保命名空间完整
        if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
            source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
            source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
        }

        // 3. 转换
        const svgBase64 = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(source)));
        const img = new Image();
        img.crossOrigin = "anonymous";

        img.onload = function() {
            try {
                const canvas = document.createElement('canvas');
                const scale = 4; // 提升至 4 倍高清渲染
                canvas.width = width * scale;
                canvas.height = height * scale;
                const ctx = canvas.getContext('2d');

                // 启用平滑绘制
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // 绘制白色背景
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 核心修复：根据 BBox 的位置进行偏移，防止图片被切掉
                ctx.scale(scale, scale);
                ctx.drawImage(img, padding - bbox.x, padding - bbox.y);

                const mimeType = format === 'png' ? 'image/png' : 'image/jpeg';
                const dataUrl = canvas.toDataURL(mimeType, 0.95); // 调高 JPG 质量

                const link = document.createElement('a');
                link.download = `客服模式对比高清图_${new Date().getTime()}.${format}`;
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error("导出失败:", e);
            }
        };
        img.src = svgBase64;
    }

    renderBtn.addEventListener('click', renderGraph);
    resetZoomBtn.addEventListener('click', () => {
        if (panZoomInstance) {
            panZoomInstance.fit();
            panZoomInstance.center();
        }
    });

    downloadBtn.addEventListener('click', () => {
        const code = editor.value;
        const tempInput = document.createElement('textarea');
        tempInput.value = code;
        document.body.appendChild(tempInput);
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);

        const originalText = downloadBtn.innerText;
        downloadBtn.innerText = '已复制!';
        setTimeout(() => downloadBtn.innerText = originalText, 2000);
    });

    window.onload = renderGraph;
</script>
</body>
</html>